λ drop (@_)

λ dup [a] (a a)

λ swap [a b] (b a)

λ over [a b] (a b a)

λ rot [a b c] (c a b)

λ drop2 (drop drop)

λ drop3 (drop drop2)

λ dup2 (dup dup)

λ dup3 (dup dup2)

λ over2 (over over)

λ over3 (over over2)

λ rot2 (rot rot)

λ clear (ζ)

λ unix_input ({} α ω ("/dev/stdin" 1 read first dup @_ + _ 10 = not))

λ panic ("PANIC: %" format putsln 1 0 %)

λ format [str] (
    str len @length
    "" @output
    0 @sp

    sp length < ω (
        str sp get @char
        char "%" =     ⇒ (output swap+ @output)
        char "%" = not ⇒ (output char+ @output)
        sp 1 + dup @sp length <
    )

    output
)

λ puts (print drop)

λ putsln ("%\n" format puts)

λ println ("%\n" format print)

λ assert_eq [value should_be content] (
    should_be value = dup bool2string content
    "% (%)" format putsln not ⇒ ("" panic)
)

λ get [] (Γ)

λ first [] (0 get)

λ second [] (1 get)

λ third [] (3 get)

λ last (dup len dec get)

λ merge ({} rot2 Ω (+) swap Ω (+))

λ count [xs x] (xs (x = dup ⇒ (1 swap) not ⇒ (0)) map sum)

λ map [fn] ({} swap Ω (fn& +))

λ filter [xs pred] ({} @out xs Ω (dup pred& ⇒ (out swap + @out)) out)

λ reduce [xs fn init] (init xs Ω (swap fn&))

λ contains [xs x] (0 @i β α ω (xs i get x = ⇒ (drop α) i inc @i i xs len <))

λ take [n] ({} @xs 0 dup n < ω (swap xs + @xs inc dup n <) xs reverse rot drop2)

λ inc (1+)

λ dec (1-)

λ len (0 swap Ω (drop inc))

λ reverse [xs] (
    {} @ys
    xs len dup 1 over2 > rot = + ω (
        dec dup xs swap get ys+ @ys dup 1 over2 > rot = +
    ) ys swap drop
)

λ push [x] ({x} swap Ω (+))

λ pop [xs] (
    {} @ys
    xs len @xs_len
    xs first 1 take @y
    1 dup xs_len < ω (xs over get ys+ @ys inc dup xs_len <)
    ys y + swap drop
)

λ string2array ({} swap Ω (+))

λ array2string ("" swap Ω (+))

λ bool2string ({{α "true"} {β "false"}} match)

λ match (
    swap @value {} swap Ω (dup first swap second @fn value = ⇒ (fn+))
    dup len null ⇒ ("Unknown case!" panic) last
)

λ xor (2 take {{{α α} β} {{β β} β} {{β α} α} {{α β} α}} match)

λ and (2 take {{{α α} α} {{β β} β} {{β α} β} {{α β} β}} match)

λ or (2 take {{{α α} α} {{β β} β} {{β α} α} {{α β} α}} match)

λ not ({{α β} {β α}} match)

λ fact [n] (1 0 dup n < ω (inc swap over * swap dup n <) drop)

λ sqrt [a] (a 0.5 * @y 0 0 α ω (a y / y + 0.5 * @y inc dup 5<) drop2 y)

λ log [base n] (0 n base gteq ω (inc n base / dup @n base gteq))

λ pow [base exp] (base exp null not ω (base * exp dec dup @exp null not) base /)

λ sum ((+) 0 reduce)

λ product ((*) 1 reduce)

λ lteq (over2 < rot = +)

λ gteq (over2 > rot = +)

λ pom (dup not)

λ inverse (1 swap /)

λ square (dup *)

λ cube (dup square *)

λ divides (% null)

λ null (0 =)

λ even (2 divides)

λ odd (2 divides not)

λ unix_random_numbers [n mod] ("/dev/random" n read (mod %) map)

λ range [start end] ({} start end < ω (start + start inc @start start end <))

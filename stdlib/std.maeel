| Drop the stack top value
fun drop
(
    -> _
)

| Duplicate the stack top value
fun dup a
(
    a a
)

| Swap the two stack top values
fun swap a b
(
    b a
)

| Push the value vmover the stack top value
| on the stack
fun over a b
(
    a b a
)

| Push the value vmover the value vmover the
| stack top value on the stack after vmswaping
| the two stack top values
fun rot a b c
(
    c a b
)

fun drop2 (
    drop drop
)

fun drop3
(
    drop drop2
)

fun vmdup2
(
    vmdup vmdup
)

fun vmdup3
(
    vmdup vmdup2
)

fun vmover2
(
    vmover vmover
)

fun vmover3
(
    vmover vmover2
)

fun vmrot2
(
    vmrot vmrot
)

fun format
(
    | Output string
    "" -> o

    for
    (
        -> char

        | If the char is a %, push the
        | stack top element (and drop it)
        char "%" =     => (o vmswap +)

        | Otherwise, push the char
        char "%" = not => (o char +) -> o
    )

    o
)

| Print and drop the stack top value
fun puts
(
    print drop
)

| Print and drop a digit
fun puts_digit
(
    int2char puts
)

| Print and drop the stack top value
| with a newline
fun putsln
(
    "%\n" format puts
)

| Print the stack top value with a newline
fun println
(
    "%\n" format print
)

| Return { fn(x) | x in xs }
fun map fn
(
    {} vmswap for (fn& +)
)

| Return ( x if p(x) | x in xs )
fun filter p
(
    {} -> ys

    for
    (
        | If P(x) is true, push x to ys
        vmdup p& => (ys vmswap + -> ys)
    )

    ys
)

fun reduce xs fn init
(
    init xs for (vmswap fn&)
)

fun match
(
    vmswap -> value

    {} vmswap for
    (
        vmdup 0 get vmswap 1 get -> fn value = => (fn+)
    )

    vmdup 0 vmswap for (drop 1+) 0 = => ("Unknown case!" panic)

    last
)

fun xor p q
(
    {p q}

    | XOR logic gate truth table
    {{{1 1} 0} {{0 0} 0} {{0 1} 1} {{1 0} 1}}

    match
)

fun and p q
(
    {p q}

    | AND logic gate truth table
    {{{1 1} 1} {{0 0} 0} {{0 1} 0} {{1 0} 0}}
    match
)

fun or p q
(
    {p q}

    | OR logic gate truth table
    {{{1 1} 1} {{0 0} 0} {{0 1} 1} {{1 0} 1}}
    match
)

fun not
(
    | NOT logic gate truth table
    {{1 0} {0 1}}
    match
)

fun panic
(
    "PANIC: %" format putsln
    1 0 %
)

fun unix_input
(
    {}

    1 while
    (
        | Read one byte from /dev/stdin
        | and add it to output array
        "/dev/stdin" 1 read 0 get vmdup vmrot +

        | Stop if char is \n
        vmswap 10 = not
    )
)

fun unix_random_numbers n mod
(
    | Read n bytes from /dev/random
    "/dev/random" n read

    | Get their modulo
    (mod %) map
)

fun assert_eq
(
    vmrot = vmdup bool2string vmrot vmrot
    "% (%)" format putsln
    not => ("" panic)
)

fun sum
((+) 0 reduce)

fun product
((*) 1 reduce)

fun null
(0 =)

fun inc
(1 +)


fun dec
(1 -)

fun divides
(
    % 0 =
)

fun even
(
    2 % 0 =
)

fun odd
(
    2 % 1 =
)

fun pom
(
    vmdup not
)

fun inverse
(
    1 vmswap/
)

fun square
(
    vmdup*
)

fun cube
(
    vmdup square*
)

fun lteq
(
    vmover vmover < vmrot = or
)

fun gteq
(
    vmover vmover > vmrot = or
)

fun len
(
    0 vmswap for (drop 1+)
)

fun first
(
    0 get
)

fun second
(
    1 get
)

fun third
(
    3 get
)

fun last
(
    vmdup 0 vmswap for (drop 1+) 1- get
)

fun merge
(
    {} vmrot vmrot for (+) vmswap for (+)
)

fun count xs x
(
    xs
    (x = vmdup => (1 vmswap) not => (0))
    map
    (+) 0 reduce
)

fun contains xs x
(
    xs 0 vmswap for (drop 1+) -> xs_len
    0 -> i

    0 1 while
    (
        xs i get x = => (drop 1)
        i 1+ -> i
        i xs_len <
    )
)

fun reverse xs
(
    {} -> ys

    xs 0 vmswap for (drop 1+) vmdup 1 gteq while
    (
        1- vmdup xs vmswap get ys+ -> ys
        vmdup 1 gteq
    )

    drop ys
)

fun pop
(
    {} -> ys

    vmdup 0 vmswap for (drop 1+) -> xs_len
    vmdup 0 get take1 -> y -> xs

    1 1 xs_len < while
    (
        xs vmover get ys+ -> ys 1+ vmdup xs_len <
    )

    ys y + vmswap drop
)

fun push
(
    take1
    vmswap
    for (+)
)

fun take n
(
    {} -> xs

    0 n range for
    (
        drop xs + -> xs
    )

    xs reverse
)

fun take1 a
(
    {a}
)

fun take2 a b
(
    {a b}
)

fun take3 a b c
(
    {a b c}
)

fun string2array
(
    {} vmswap
    for (+)
)

| Convert a digit to a char
fun int2char
(
    {{0 "0"} {1 "1"} {2 "2"} {3 "3"} {4 "4"}
    {5 "5"} {6 "6"} {7 "7"} {8 "8"} {9 "9"}}
    match
)

| Convert a single character into an integer
fun char2int
(
    {{"0" 0} {"1" 1} {"2" 2} {"3" 3} {"4" 4}
    {"5" 5} {"6" 6} {"7" 7} {"8" 8} {"9" 9}}
    match
)

| Convert a string into an integer
fun str2int
(
    0 vmswap for
    (
        vmswap 10 * vmswap char2int +
    )
)

| Convert an array into a string
fun array2string
(
    "" vmswap
    for (+)
)

fun bool2string
(
    {{1 "true"} {0 "false"}}
    match
)

fun fact n
(
    1 n 1 + range product
)

| Square root approximation
fun sqrt x
(
    0 5 range
    (vmdup x vmswap/ vmswap+ 2/ vmswap drop)
    x 2/
    reduce
)

fun log base n
(
    0

    n base gteq while
    (
        | Increase the counter
        1+

        | Put n/base into n
        n base / vmdup -> n

        | if n <= base, then continue
        base gteq
    )
)

fun pow base exp
(
    | Generate a list of size 'exp' with only 'base'
    | and multiply all these 'base' togather
    0 exp range (drop base) map product
)

fun range
(
    vmover vmover < vmrot ->end ->start
    {} vmswap while
    (
        start+ start 1+ vmdup ->start end <
    )
)

fun drop
(
    -> _
)

fun dup a
(
    a a
)

fun swap a b
(
    b a
)

fun over a b
(
    a b a
)

fun rot a b c
(
    c a b
)

fun format
(
    | Output string
    "" -> o

    for
    (
        -> char
        char "%" =     => (o vmswap +)
        char "%" = not => (o char +) -> o
    )

    o
)

fun inline puts
(
    print vmdrop
)

fun inline puts_digit
(
    int2char puts
)

fun inline putsln
(
    "%\n" format puts
)

fun inline println
(
    "%\n" format print
)

fun map fn
(
    {} vmswap for (fn& +)
)

fun filter p
(
    {} -> ys

    for
    (
        vmdup p& => (ys vmswap + -> ys)
    )

    ys
)

fun reduce xs fn init
(
    init xs for (vmswap fn&)
)

fun match
(
    vmswap -> value
    {} vmswap for (vmdup 0 get vmswap 1 get -> fn value= => (fn+))
    vmdup 0 vmswap for (vmdrop 1+) dup
    0= => ("Unknown case!" panic)
    1- get
)

fun xor p q
(
    {p q}
    {{{1 1} 0} {{0 0} 0} {{0 1} 1} {{1 0} 1}}
    match
)

fun inline and
(
    + 2 =
)

fun inline or
(
    + vmdup 2 = => (1 -)
)

fun inline not
(
    vmdup 0 = => (1 vmswap) 1 = => 0
)

fun inline panic
(
    "PANIC: %" format putsln 1 0 %
)

fun inline unix_input
(
    {}

    1 while
    (
        "/dev/stdin" 1 read 0 get vmdup vmrot +
        vmswap 10 = not
    )
)

fun unix_random_numbers n mod
(
    "/dev/random" n read (mod %) map
)

fun inline assert_eq
(
    vmrot = vmdup bool2string vmrot vmrot
    "% (%)" format putsln
    not => ("" panic)
)

fun inline sum
((+) 0 reduce)

fun inline product
((*) 1 reduce)

fun inline null
(0 =)

fun inline inc
(1 +)

fun inline dec
(1 -)

fun inline divides
(
    % 0 =
)

fun inline even
(
    2 % 0 =
)

fun inline odd
(
    2 % 1 =
)

fun inline positive
(
    vmdup 0 = => (1 vmswap) 0 > => 1
)

fun inline pom
(
    vmdup not
)

fun inline inverse
(
    1 vmswap/
)

fun inline square
(
    vmdup*
)

fun inline cube
(
    vmdup vmdup*
)

fun inline lteq
(
    vmover vmover < vmrot = or
)

fun inline gteq
(
    vmover vmover > vmrot = or
)

fun inline len
(
    0 vmswap for (vmdrop 1+)
)

fun inline first
(
    0 get
)

fun inline second
(
    1 get
)

fun inline third
(
    3 get
)

fun inline last
(
    vmdup 0 vmswap for (vmdrop 1+) 1- get
)

fun inline merge
(
    {} vmrot vmrot for (+) vmswap for (+)
)

fun count xs x
(
    xs
    (x = vmdup => (1 vmswap) not => 0)
    map
    (+) 0 reduce
)

fun contains xs x
(
    xs 0 vmswap for (vmdrop 1+) -> xs_len
    0 -> i

    0 1 while
    (
        xs i get x = => (vmdrop 1)
        i 1 + -> i
        i xs_len <
    )
)

fun reverse xs
(
    {} -> ys

    xs 0 vmswap for (vmdrop 1+) vmdup 1 gteq while
    (
        1- vmdup xs vmswap get ys+ -> ys
        vmdup 1 gteq
    )

    vmdrop ys
)

fun pop
(
    {} -> ys

    vmdup 0 vmswap for (vmdrop 1+) -> xs_len
    vmdup 0 get take1 -> y -> xs

    1 1 xs_len < while
    (
        xs vmover get ys+ -> ys 1+ vmdup xs_len <
    )

    ys y + vmswap vmdrop
)

fun inline push
(
    take1 vmswap for (+)
)

fun take n
(
    {} -> xs

    0 n range for (vmdrop xs + -> xs)

    xs reverse
)

fun take1 a
(
    {a}
)

fun take2 a b
(
    {a b}
)

fun take3 a b c
(
    {a b c}
)

fun string2array
(
    {} vmswap for (+)
)

| Convert a digit to a char
fun inline int2char
(
    {{0 "0"} {1 "1"} {2 "2"} {3 "3"} {4 "4"}
    {5 "5"} {6 "6"} {7 "7"} {8 "8"} {9 "9"}}
    match
)

| Convert a single character into an integer
fun inline char2int
(
    {{"0" 0} {"1" 1} {"2" 2} {"3" 3} {"4" 4}
    {"5" 5} {"6" 6} {"7" 7} {"8" 8} {"9" 9}}
    match
)

| Convert a string into an integer
fun inline str2int
(
    0 vmswap for (vmswap 10 * vmswap char2int +)
)

| Convert an array into a string
fun inline array2string
(
    "" vmswap for (+)
)

fun inline bool2string
(
    {{1 "true"} {0 "false"}} match
)

fun inline fact (
    vmdup vmdup 1 > while (
        1 - vmdup vmrot * vmswap
        vmdup 1 >
    ) vmdrop
)

fun sqrt x
(
    0 5 range
    (vmdup x vmswap / vmswap+ 2 / vmswap vmdrop)
    x 2 /
    reduce
)

fun log base n
(
    0 n base gteq while
    (1 + n base / vmdup -> n base gteq)
)

fun pow base exp
(
    0 exp range (vmdrop base) map product
)

fun range
(
    vmover vmover < vmrot -> e -> s
    {} vmswap while (s + s 1 + vmdup -> s e <)
)

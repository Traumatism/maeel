{"std" "maths" "array" "logic" "stack"} Ω (include)

1 2 3 3 take                            {1 2 3}                     "take #1"                   assert_eq
3 2 +                                   5                           "add #1"                    assert_eq
3 2 *                                   6                           "mul #1"                    assert_eq
0 1 2 3 drop 3 take                     {0 1 2}                     "drop #1"                   assert_eq
1 2 3 dup 4 take                        {1 2 3 3}                   "dup #1"                    assert_eq
1 2 3 swap 3 take                       {1 3 2}                     "swap #1"                   assert_eq
1 2 3 swap swap 3 take                  {1 2 3}                     "swap #2"                   assert_eq
1 2 3 over 4 take                       {1 2 3 2}                   "over #1"                   assert_eq
1 2 3 over over 5 take                  {1 2 3 2 3}                 "over #2"                   assert_eq
1 2 3 rot 3 take                        {3 1 2}                     "rot #1"                    assert_eq
1 2 3 rot rot 3 take                    {2 3 1}                     "rot #2"                    assert_eq
1 2 3 rot rot rot 3 take                {1 2 3}                     "rot #3"                    assert_eq
α not                                   β                           "not #1"                    assert_eq
β not                                   α                           "not #2"                    assert_eq
α α and                                 α                           "and #1"                    assert_eq
α β and                                 β                           "and #2"                    assert_eq
β α and                                 β                           "and #3"                    assert_eq
β β and                                 β                           "and #4"                    assert_eq
α α or                                  α                           "or #1"                     assert_eq
α β or                                  α                           "or #2"                     assert_eq
β α or                                  α                           "or #3"                     assert_eq
β β or                                  β                           "or #4"                     assert_eq
α α xor                                 β                           "xor #1"                    assert_eq
α β xor                                 α                           "xor #2"                    assert_eq
β α xor                                 α                           "xor #3"                    assert_eq
β β xor                                 β                           "xor #4"                    assert_eq
{1 2 3} last                            3                           "last #1"                   assert_eq
{1 2 3} first                           1                           "first #1"                  assert_eq
| {1 1 2} 1 count                         2                           "count #1"                  assert_eq
| {1 1 2} 2 count                         1                           "count #2"                  assert_eq
| {1 1 2} 3 count                         0                           "count #3"                  assert_eq
{1 2 3} (1+) map                        {2 3 4}                     "map #1"                    assert_eq
{1 2 3} 1 contains                      α                           "contains #1"               assert_eq
{1 2 3} 4 contains                      β                           "contains #2"               assert_eq
{1 2 3} len                             3                           "len #1"                    assert_eq
{1} len                                 1                           "len #2"                    assert_eq
{} len                                  0                           "len #3"                    assert_eq
{1 2 3} reverse                         {3 2 1}                     "reverse #1"                assert_eq
{} reverse                              {}                          "reverse #2"                assert_eq
{1 2 3} 0 push                          {0 1 2 3}                   "push #1"                   assert_eq
{1 2 3} {4 5 6} merge                   {1 2 3 4 5 6}               "union #1"                  assert_eq
{1 2 3} 4 +                             {1 2 3 4}                   "append #1"                 assert_eq
1 {{1 "one"} {2 "two"}} match           "one"                       "match #1"                  assert_eq
2 {{1 "one"} {2 "two"}} match           "two"                       "match #2"                  assert_eq


"foo" → foo
("bar" → foo) → might_change_foo
might_change_foo&

foo "foo" "Function (anonymous) side effect" assert_eq

λ might_change_foo [] ("bar" → foo)
might_change_foo

foo "foo" "Function (named) side effect" assert_eq

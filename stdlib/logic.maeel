"stack" include
"array" include


λ match [value mp] (
    {}

    mp Ω (
        dup 0 get swap 1 get @fn @element
        element value = ⇒ (fn +)
    )

    last
)

λ xor [] (over over * not rot + *)

λ and [] (*)

λ or [] (+)

λ not [a] (a α = ⇒ (β) a β = ⇒ (α))

λ then [val fn] (val ⇒ (fn&))

λ equiv [f1 f2] (
    {} dup @result_f1 @result_f2
    { α β } dup * dup

    Ω (dup 0Γ swap 1Γ f1& result_f1+ →result_f1)
    Ω (dup 0Γ swap 1Γ f2& result_f2+ →result_f2)

    result_f1 result_f2 =
)
